# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
===================
sbpy.data.ephem.cli
===================

Ephemerides may be generated by this module via the ``sbpy-ephem`` command line script.

"""

import numpy as np
import sys
import argparse
from typing import Any, Dict, List, Optional, Set, Union

import astropy.units as u
from astropy.time import Time
from astropy.coordinates import Angle

from .core import Ephem, EphemerisService
from ..names import Names, TargetNameParseError
from ...utils.decorators import requires


class StoreEphemerisService(argparse.Action):
    """Helper class to support ``EphemerisService`` objects in argparse
    arguments."""

    def __call__(self, parser, namespace, values, option_string=None):
        value = EphemerisService(values)
        setattr(namespace, self.dest, value)


class EphemerisCLI:
    """Command-line interface for ephemeris generation.

    Use this class via the command line-line script ``sbpy-ephem``.


    Parameters
    ----------
    argv : list of str, optional
        Parse command line parameters from this list, rather than sys.argv.

    """

    @requires("astroquery")
    def __init__(self, argv: Optional[List[str]] = None) -> None:
        self.args: argparse.Namespace = self.parse_args(argv)
        self.epochs: Dict[str, Any] = self._format_epochs(self.args)

        self.eph: Ephem
        if self.args.service == EphemerisService.mpc:
            self.eph = self.mpc()
        elif self.args.service == EphemerisService.horizons:
            self.eph = self.horizons()
        elif self.args.service == EphemerisService.miriade:
            self.eph = self.miriade()

        self.eph: Ephem = self._format_eph(self.eph)

    @classmethod
    def run(cls) -> None:  # pragma: no cover
        """Command-line script entry point."""
        try:
            cli = cls()
        except Exception as e:
            # check for debug flag
            if any([x == "--debug" for x in sys.argv]):
                raise e
            print(str(e), file=sys.stderr)
            sys.exit(1)

        print(
            f"""# requested target: {cli.args.target}
# returned target: {cli.eph.meta['target']}
# location: {cli.args.location}"""
        )
        cli.eph.table.pprint_all()

    @staticmethod
    def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
        """Parse command-line arguments.

        Parameters
        ----------
        argv : list of str, optional
            Parse command line parameters from this list, rather than sys.argv.

        """

        today: Time = Time(Time.now().iso[:10])

        parser: argparse.ArgumentParser = argparse.ArgumentParser()
        # names in choices must have entries in `EphemerisService`
        parser.add_argument(
            "service",
            choices=[
                str(EphemerisService.horizons),
                str(EphemerisService.miriade),
                str(EphemerisService.mpc),
            ],
            action=StoreEphemerisService,
            help="online service to use for ephemeris",
        )
        parser.add_argument(
            "target",
        )
        parser.add_argument(
            "--location",
            "-l",
            default="500",
            help="observer location as a Minor Planet Center observatory code, e.g., G37",
        )
        parser.add_argument(
            "--start",
            default=today,
            type=Time,
            help="start time (e.g., YYYY-MM-DD), default today [UTC]",
        )
        parser.add_argument(
            "--step",
            default="1 d",
            type=u.Quantity,
            help="ephemeris step size with units (d, h, min)",
        )

        stop_number_mutex = parser.add_mutually_exclusive_group()
        stop_number_mutex.add_argument(
            "--stop",
            "--end",
            type=Time,
            help="stop time (e.g., YYYY-MM-DD) [UTC]",
        )
        stop_number_mutex.add_argument(
            "--number",
            "-n",
            type=int,
            help="number of time steps",
        )

        parser.add_argument(
            "--radec",
            "-r",
            default="hmsdms",
            choices=("hmsdms", "deg"),
            help="RA, Dec coordinate output format",
        )

        horizons: argparse._ArgumentGroup = parser.add_argument_group(
            "JPL Horizons options"
        )
        horizons.add_argument(
            "--id-type",
            "-i",
            default=None,
            choices=(
                "smallbody",
                "designation",
                "name",
                "asteroid_name",
                "comet_name",
            ),
            help=(
                "target identifer type; automatically set to 'designation' for "
                "target names that appear to be a cometary designation"
            ),
        )
        horizons.add_argument(
            "--quantities",
            "-q",
            default="1,3,9,19,20,23,24,27,33",
            help="table quantities to return as a comma-separated list of integers (default: 1,3,9,19,20,23,24,27,33)",
        )

        miriade: argparse._ArgumentGroup = parser.add_argument_group(
            "IMCCE Miriade options"
        )
        miriade.add_argument(
            "--type",
            "-t",
            default="asteroid",
            choices=(
                "asteroid",
                "comet",
                "dwarf planet",
                "planet",
                "satellite",
            ),
            help="target identifer type",
        )

        parser.add_argument(
            "--debug", action="store_true", help="print debugging information"
        )

        args = parser.parse_args(argv)

        # parameter checks:
        if args.stop is not None and args.start > args.stop:
            raise ValueError("start cannot be after stop")

        return args

    @staticmethod
    def _format_epochs(args) -> Dict[str, Any]:
        """Format the epochs dictionary."""

        epochs: dict = {
            "start": args.start,
            "step": args.step,
            "stop": args.stop,
        }
        defined_attributes: Set[str] = {
            k
            for k in ["start", "stop", "step", "number"]
            if getattr(args, k) is not None
        }

        def given(*attributes):
            return set(attributes) == defined_attributes

        # start and step are always defined by parse_args
        if given("start", "step"):
            # default is 60 steps
            epochs["stop"] = epochs["start"] + 60 * epochs["step"]
        elif given("start", "step", "number"):
            epochs["stop"] = epochs["start"] + args.number * epochs["step"]

        return epochs

    def mpc(self) -> Ephem:
        """Get ephemeris from the Minor Planet Center."""

        eph = Ephem.from_mpc(
            self.args.target,
            epochs=self.epochs,
            location=self.args.location,
        )
        return eph

    def horizons(self) -> Ephem:
        """Get ephemeris from Horizons."""

        # comet specific options: always avoid multiple fragment matches, always
        # return closest apparition
        closest_apparition: bool = False
        no_fragments: bool = False
        id_type: Union[str, None] = self.args.id_type
        try:
            Names.parse_comet(self.args.target)
            jd_mid = np.mean((self.epochs["start"].jd, self.epochs["stop"].jd))
            closest_apparition = f"<{jd_mid:.0f}"
            no_fragments = True
            id_type = "designation" if id_type is None else id_type
        except TargetNameParseError:
            pass

        eph = Ephem.from_horizons(
            self.args.target,
            id_type=id_type,
            closest_apparition=closest_apparition,
            no_fragments=no_fragments,
            epochs=self.epochs,
            location=self.args.location,
            quantities=self.args.quantities,
        )

        # simplify output
        eph["epoch"].format = "iso"
        eph["ra"] = eph["ra"].unmasked
        eph["dec"] = eph["dec"].unmasked
        for k in ["M1", "k1", "solar_presence", "lunar_presence"]:
            if k in eph.table.colnames:
                del eph.table[k]

        return eph

    def miriade(self) -> Ephem:
        """Get ephemeris from Miriade."""

        eph = Ephem.from_miriade(
            self.args.target,
            objtype=self.args.type,
            epochs=self.epochs,
            location=self.args.location,
            coordtype=1,
        )

        # simplify output
        eph["epoch"].format = "iso"

        for k in eph.field_names:
            if hasattr(eph[k], "unmasked"):
                eph[k] = eph[k].unmasked

        return eph

    def _format_eph(self, eph: Ephem) -> Ephem:
        # convert RA and Dec to Angle in units of degree
        eph["ra"] = Angle(eph["ra"], eph["ra"].unit).to("deg")
        eph["dec"] = Angle(eph["dec"], eph["dec"].unit).to("deg")

        if self.args.radec == "hmsdms":
            eph["ra"].info.format = lambda x: x.to_string(
                sep=":", precision=2, unit="hourangle"
            )
            eph["dec"].info.format = lambda x: x.to_string(sep=":", precision=1)
        else:
            eph["ra"].info.format = lambda x: x.to_string(
                unit="deg", decimal=True, precision=5
            )
            eph["dec"].info.format = lambda x: x.to_string(
                unit="deg", decimal=True, precision=5
            )

        # normalize output for most common columns
        first_fields: List[str] = [
            "target",
            "date",
            "RA",
            "Dec",
            "rh",
            "delta",
            "phase",
            "solarelong",
            "DEC_rate",
            "RA*cos(Dec)_rate",
        ]

        k: str
        translated: str
        for k in first_fields:
            if k not in eph:
                continue
            translated = eph._translate_columns(k)[0]
            eph.table.rename_column(translated, k)

        # re-order
        fields: List[str] = eph.field_names
        for k in reversed(first_fields):
            if k not in fields:
                continue
            fields.insert(0, fields.pop(fields.index(k)))

        eph = eph[fields]
        target = eph["target"][0]
        del eph.table["target"]
        eph.table.meta["target"] = target

        return eph
